{"ast":null,"code":"import { mix } from '../../utils/mix.mjs';\nimport { hasTransform } from '../utils/has-transform.mjs';\n/**\n * Scales a point based on a factor and an originPoint\n */\n\nfunction scalePoint(point, scale, originPoint) {\n  const distanceFromOrigin = point - originPoint;\n  const scaled = scale * distanceFromOrigin;\n  return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\n\n\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n  if (boxScale !== undefined) {\n    point = scalePoint(point, boxScale, originPoint);\n  }\n\n  return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\n\n\nfunction applyAxisDelta(axis) {\n  let translate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let scale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  let originPoint = arguments.length > 3 ? arguments[3] : undefined;\n  let boxScale = arguments.length > 4 ? arguments[4] : undefined;\n  axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n  axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\n\n\nfunction applyBoxDelta(box, _ref) {\n  let {\n    x,\n    y\n  } = _ref;\n  applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n  applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\n\n\nfunction applyTreeDeltas(box, treeScale, treePath) {\n  let isSharedTransition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  const treeLength = treePath.length;\n  if (!treeLength) return; // Reset the treeScale\n\n  treeScale.x = treeScale.y = 1;\n  let node;\n  let delta;\n\n  for (let i = 0; i < treeLength; i++) {\n    node = treePath[i];\n    delta = node.projectionDelta;\n    /**\n     * TODO: Prefer to remove this, but currently we have motion components with\n     * display: contents in Framer.\n     */\n\n    const instance = node.instance;\n\n    if (instance && instance.style && instance.style.display === \"contents\") {\n      continue;\n    }\n\n    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {\n      transformBox(box, {\n        x: -node.scroll.offset.x,\n        y: -node.scroll.offset.y\n      });\n    }\n\n    if (delta) {\n      // Incoporate each ancestor's scale into a culmulative treeScale for this component\n      treeScale.x *= delta.x.scale;\n      treeScale.y *= delta.y.scale; // Apply each ancestor's calculated delta into this component's recorded layout box\n\n      applyBoxDelta(box, delta);\n    }\n\n    if (isSharedTransition && hasTransform(node.latestValues)) {\n      transformBox(box, node.latestValues);\n    }\n  }\n  /**\n   * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n   * This will help reduce useless scales getting rendered.\n   */\n\n\n  treeScale.x = snapToDefault(treeScale.x);\n  treeScale.y = snapToDefault(treeScale.y);\n}\n\nfunction snapToDefault(scale) {\n  if (Number.isInteger(scale)) return scale;\n  return scale > 1.0000000000001 || scale < 0.999999999999 ? scale : 1;\n}\n\nfunction translateAxis(axis, distance) {\n  axis.min = axis.min + distance;\n  axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\n\n\nfunction transformAxis(axis, transforms, _ref2) {\n  let [key, scaleKey, originKey] = _ref2;\n  const axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n  const originPoint = mix(axis.min, axis.max, axisOrigin); // Apply the axis delta to the final axis\n\n  applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\n\n\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\n\nfunction transformBox(box, transform) {\n  transformAxis(box.x, transform, xKeys);\n  transformAxis(box.y, transform, yKeys);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };","map":{"version":3,"names":["mix","hasTransform","scalePoint","point","scale","originPoint","distanceFromOrigin","scaled","applyPointDelta","translate","boxScale","undefined","applyAxisDelta","axis","min","max","applyBoxDelta","box","x","y","applyTreeDeltas","treeScale","treePath","isSharedTransition","treeLength","length","node","delta","i","projectionDelta","instance","style","display","options","layoutScroll","scroll","root","transformBox","offset","latestValues","snapToDefault","Number","isInteger","translateAxis","distance","transformAxis","transforms","key","scaleKey","originKey","axisOrigin","xKeys","yKeys","transform"],"sources":["/Users/macbook/Downloads/country_details/node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs"],"sourcesContent":["import { mix } from '../../utils/mix.mjs';\nimport { hasTransform } from '../utils/has-transform.mjs';\n\n/**\n * Scales a point based on a factor and an originPoint\n */\nfunction scalePoint(point, scale, originPoint) {\n    const distanceFromOrigin = point - originPoint;\n    const scaled = scale * distanceFromOrigin;\n    return originPoint + scaled;\n}\n/**\n * Applies a translate/scale delta to a point\n */\nfunction applyPointDelta(point, translate, scale, originPoint, boxScale) {\n    if (boxScale !== undefined) {\n        point = scalePoint(point, boxScale, originPoint);\n    }\n    return scalePoint(point, scale, originPoint) + translate;\n}\n/**\n * Applies a translate/scale delta to an axis\n */\nfunction applyAxisDelta(axis, translate = 0, scale = 1, originPoint, boxScale) {\n    axis.min = applyPointDelta(axis.min, translate, scale, originPoint, boxScale);\n    axis.max = applyPointDelta(axis.max, translate, scale, originPoint, boxScale);\n}\n/**\n * Applies a translate/scale delta to a box\n */\nfunction applyBoxDelta(box, { x, y }) {\n    applyAxisDelta(box.x, x.translate, x.scale, x.originPoint);\n    applyAxisDelta(box.y, y.translate, y.scale, y.originPoint);\n}\n/**\n * Apply a tree of deltas to a box. We do this to calculate the effect of all the transforms\n * in a tree upon our box before then calculating how to project it into our desired viewport-relative box\n *\n * This is the final nested loop within updateLayoutDelta for future refactoring\n */\nfunction applyTreeDeltas(box, treeScale, treePath, isSharedTransition = false) {\n    const treeLength = treePath.length;\n    if (!treeLength)\n        return;\n    // Reset the treeScale\n    treeScale.x = treeScale.y = 1;\n    let node;\n    let delta;\n    for (let i = 0; i < treeLength; i++) {\n        node = treePath[i];\n        delta = node.projectionDelta;\n        /**\n         * TODO: Prefer to remove this, but currently we have motion components with\n         * display: contents in Framer.\n         */\n        const instance = node.instance;\n        if (instance &&\n            instance.style &&\n            instance.style.display === \"contents\") {\n            continue;\n        }\n        if (isSharedTransition &&\n            node.options.layoutScroll &&\n            node.scroll &&\n            node !== node.root) {\n            transformBox(box, {\n                x: -node.scroll.offset.x,\n                y: -node.scroll.offset.y,\n            });\n        }\n        if (delta) {\n            // Incoporate each ancestor's scale into a culmulative treeScale for this component\n            treeScale.x *= delta.x.scale;\n            treeScale.y *= delta.y.scale;\n            // Apply each ancestor's calculated delta into this component's recorded layout box\n            applyBoxDelta(box, delta);\n        }\n        if (isSharedTransition && hasTransform(node.latestValues)) {\n            transformBox(box, node.latestValues);\n        }\n    }\n    /**\n     * Snap tree scale back to 1 if it's within a non-perceivable threshold.\n     * This will help reduce useless scales getting rendered.\n     */\n    treeScale.x = snapToDefault(treeScale.x);\n    treeScale.y = snapToDefault(treeScale.y);\n}\nfunction snapToDefault(scale) {\n    if (Number.isInteger(scale))\n        return scale;\n    return scale > 1.0000000000001 || scale < 0.999999999999 ? scale : 1;\n}\nfunction translateAxis(axis, distance) {\n    axis.min = axis.min + distance;\n    axis.max = axis.max + distance;\n}\n/**\n * Apply a transform to an axis from the latest resolved motion values.\n * This function basically acts as a bridge between a flat motion value map\n * and applyAxisDelta\n */\nfunction transformAxis(axis, transforms, [key, scaleKey, originKey]) {\n    const axisOrigin = transforms[originKey] !== undefined ? transforms[originKey] : 0.5;\n    const originPoint = mix(axis.min, axis.max, axisOrigin);\n    // Apply the axis delta to the final axis\n    applyAxisDelta(axis, transforms[key], transforms[scaleKey], originPoint, transforms.scale);\n}\n/**\n * The names of the motion values we want to apply as translation, scale and origin.\n */\nconst xKeys = [\"x\", \"scaleX\", \"originX\"];\nconst yKeys = [\"y\", \"scaleY\", \"originY\"];\n/**\n * Apply a transform to a box from the latest resolved motion values.\n */\nfunction transformBox(box, transform) {\n    transformAxis(box.x, transform, xKeys);\n    transformAxis(box.y, transform, yKeys);\n}\n\nexport { applyAxisDelta, applyBoxDelta, applyPointDelta, applyTreeDeltas, scalePoint, transformAxis, transformBox, translateAxis };\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}